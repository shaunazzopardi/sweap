//-- State: counter, buttonUp, buttonDown
//-- Inputs: buttonPressedUp, buttonPressedDown

//#LIA#

assume {
  //inRange counter;
  eq counter c0();
  eq buttonPressedUp c0();
  eq buttonPressedDown c0();
}

always assume {
  (eq buttonPressedUp c0() || eq buttonPressedDown c0());
  eq buttonPressedUp c0() || eq buttonPressedUp c1();
  eq buttonPressedDown c0() || eq buttonPressedDown c1();

  [ buttonUp <- c0() ]
    -> X ([ buttonUp <- c1() ] R (eq buttonPressedUp c0()));

  [ buttonDown <- c0() ]
    -> X ([ buttonDown <- c1() ] R (eq buttonPressedDown c0()));
}

always guarantee {
  le (add counter c2()) c100() &&
  le (add counter c1()) c100()
    -> [ buttonUp <- c1() ];

  ge (sub counter c2()) c0() &&
  ge (sub counter c1()) c0()
    -> [ buttonDown <- c1() ];

  (eq buttonPressedUp c1())   <-> [ counter <- add counter c1() ];
  (eq buttonPressedDown c1()) <-> [ counter <- sub counter c1() ];

  //inRange counter;
  ge counter c0();
  le counter c100();
}
