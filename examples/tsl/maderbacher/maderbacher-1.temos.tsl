//-- State: counter, started
//-- Inputs: start

// This is trivially unrealizable

//#LIA#

assume {
  eq counter c0();
  eq started c0();
}

always assume {
  eq start c0() || eq start c1();
}

guarantee {
  G (eq start c1() -> F (lt counter c0()));
}

always guarantee {
  ge counter c0(); /* INV */
  le counter c1(); /* INV */

  eq started c0() && eq start c0() -> [started <- c0()] && [counter <- add counter c1()];
  eq started c0() && eq start c1() -> [started <- c1()];
  eq started c1() -> ([ counter <- add counter c1() ] || [ counter <- sub counter c1() ]);

}
