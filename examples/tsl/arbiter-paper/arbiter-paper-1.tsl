//-- State: counter, roomA, pending, q, grantA, grantB
//-- Inputs: request, changeRoom

//#LIA#

assume {
  eq counter i0();
  eq q i0();
  eq grantA i0();
  eq grantB i0();
  eq pending i0();
}

always assume {
  ge request i0();
  le request i1();
  ge changeRoom i0();
  le changeRoom i1();
}

always guarantee {
  ge counter i0(); /* INV */
  le counter i1(); /* INV */

  ge grantA i0(); /* INV */
  le grantA i1(); /* INV */
  ge grantB i0(); /* INV */
  le grantB i1(); /* INV */

  ((eq q i0()) && (eq request i1()) && (eq changeRoom i0()) && (lt counter i1())) -> ([counter <- add counter i1()] && [pending <- i1()]);
  ((eq q i0()) && (eq request i0()) && (eq changeRoom i1()) && (eq roomA i0())) -> [roomA <- i1()];
  ((eq q i0()) && (eq request i0()) && (eq changeRoom i1()) && (eq roomA i1())) -> [roomA <- i0()];
  ((eq q i0()) && (eq request i0()) && (eq changeRoom i0())) -> [q <- i1()];
  
  [grantA <- i1()] -> ((eq q i1()) && [grantB <- i0()] && (gt counter i0()) && [counter <- sub counter i1()]);
  [grantB <- i1()] -> ((eq q i1()) && [grantA <- i0()] && (gt counter i0()) && [counter <- sub counter i1()]);

  ((eq q i1()) && (eq counter i0())) -> ([pending <- i0()] && [q <- i0()]);



  (eq pending i1() && (eq request i0()) && (eq changeRoom i0())) -> F (eq pending i0());


}
