//-- State: counter, roomA, pending, q, grantA, grantB
//-- Inputs: request, changeRoom

//#LIA#

assume {
  eq counter i0();
  eq q i0();
  eq grantA i0();
  eq grantB i0();
  eq pending i0();
}

always assume {
  ge request i0();
  le request i1();
  ge changeRoom i0();
  le changeRoom i1();
}

always guarantee {
  ge counter i0(); /* INV */
  le counter i15(); /* INV */

  eq grantA i0() || eq grantA i1(); /* INV */
  eq grantB i0() || eq grantB i1(); /* INV */


  (eq q i0()) && (eq request i1() && (eq changeRoom i0())) -> [counter <- add counter i1()] && [pending <- i1()];
  (eq q i0()) && (eq request i0() && (eq changeRoom i1()) && (eq roomA i0())) -> [roomA <- i1()];
  (eq q i0()) && (eq request i0() && (eq changeRoom i1()) && (eq roomA i1())) -> [roomA <- i0()];
  (eq q i0()) && (eq request i0() && (eq changeRoom i0())) -> [q <- i1()];
  
  [grantA <- i1()] -> (eq q i1()) && [grantB <- i0()] && (gt counter i0()) && [counter <- sub counter i1()];
  [grantB <- i1()] -> (eq q i1()) && [grantA <- i0()] && (gt counter i0()) && [counter <- sub counter i1()];

  (eq q i1()) && (eq counter i0()) -> [pending <- i0()] && [q <- i0()];


  (eq pending i1() && (eq request i0()) && (eq changeRoom i0())) -> F (eq pending i0());


}
